<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- The title will be updated from /title.txt -->
    <title>Loadingâ€¦</title>
    <style>
      /* DARK MODE / MODERN STYLE */
      :root {
        --bg-color: #121212;
        --text-color: #e0e0e0;
        --accent-color: #bb86fc;
        --control-bg: #1f1b24;
        --control-hover: #333;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }
      header {
        text-align: center;
        padding: 1rem;
        border-bottom: 1px solid #333;
      }
      .container {
        flex: 1;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .player {
        width: 100%;
        max-width: 500px;
        background-color: var(--control-bg);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
      }
      .time-display {
        text-align: center;
        margin-bottom: 0.5rem;
      }
      input[type="range"] {
        width: 100%;
        margin: 0.5rem 0;
      }
      .controls {
        display: flex;
        justify-content: space-around;
        align-items: center;
      }
      button {
        background-color: var(--accent-color);
        color: var(--bg-color);
        border: none;
        padding: 0.5rem 1rem;
        font-size: 1rem;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover {
        background-color: var(--control-hover);
      }
      .content {
        width: 100%;
        max-width: 500px;
      }
      .content p {
        background-color: var(--control-bg);
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 0.5rem;
        line-height: 1.4;
      }
    </style>
  </head>
  <body>
    <header>
      <h1 id="pageTitle">Music Player</h1>
    </header>
    <div class="container">
      <div class="player">
        <!-- Display current time and total duration -->
        <div class="time-display">
          <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
        </div>
        <!-- Scrubber / Progress Bar -->
        <input type="range" id="scrubber" value="0" min="0" max="100" step="0.1" />
        <!-- Player Controls -->
        <div class="controls">
          <button id="backButton">-10s</button>
          <button id="playPauseButton">Play</button>
          <button id="forwardButton">+10s</button>
        </div>
        <!-- Hidden audio element; the source will be set after processing -->
        <audio id="mainAudio" loop></audio>
      </div>
      <!-- Text content will be loaded from /text.txt -->
      <div class="content" id="textContent"></div>
    </div>
    <script>
      /* Utility: Format a number of seconds as MM:SS */
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return (
          (mins < 10 ? "0" + mins : mins) +
          ":" +
          (secs < 10 ? "0" + secs : secs)
        );
      }

      /* Update title from /title.txt */
      fetch("/title.txt")
        .then((response) => response.text())
        .then((data) => {
          const title = data.trim();
          document.title = title;
          document.getElementById("pageTitle").textContent = title;
        })
        .catch((error) => {
          console.error("Error fetching title:", error);
        });

      /* Fetch /text.txt and display the text as paragraphs */
      fetch("/text.txt")
        .then((response) => response.text())
        .then((data) => {
          const contentDiv = document.getElementById("textContent");
          // Split text by empty lines (double newline)
          const paragraphs = data.split(/\r?\n\r?\n/);
          paragraphs.forEach((para) => {
            const p = document.createElement("p");
            p.textContent = para;
            contentDiv.appendChild(p);
          });
        })
        .catch((error) => {
          console.error("Error fetching text:", error);
        });

      /* Binaural Beats Setup */
      let binauralContext = null;
      let rightOscillator = null;
      let leftOscillator = null;

      function startBinauralBeats() {
        if (binauralContext) return; // Already running

        binauralContext =
          new (window.AudioContext || window.webkitAudioContext)();

        // RIGHT CHANNEL: 130 Hz
        rightOscillator = binauralContext.createOscillator();
        rightOscillator.frequency.value = 130;
        const rightGain = binauralContext.createGain();
        // Start with 0 gain and fade in to 0.004 in 2 seconds
        rightGain.gain.setValueAtTime(0, binauralContext.currentTime);
        rightGain.gain.linearRampToValueAtTime(
          0.004,
          binauralContext.currentTime + 2
        );
        const rightPanner = binauralContext.createStereoPanner();
        rightPanner.pan.value = 1; // Right

        rightOscillator
          .connect(rightGain)
          .connect(rightPanner)
          .connect(binauralContext.destination);

        // LEFT CHANNEL: 100 Hz
        leftOscillator = binauralContext.createOscillator();
        leftOscillator.frequency.value = 100;
        const leftGain = binauralContext.createGain();
        leftGain.gain.setValueAtTime(0, binauralContext.currentTime);
        leftGain.gain.linearRampToValueAtTime(
          0.004,
          binauralContext.currentTime + 2
        );
        const leftPanner = binauralContext.createStereoPanner();
        leftPanner.pan.value = -1; // Left

        leftOscillator
          .connect(leftGain)
          .connect(leftPanner)
          .connect(binauralContext.destination);

        rightOscillator.start();
        leftOscillator.start();
      }

      function stopBinauralBeats() {
        try {
          if (rightOscillator) rightOscillator.stop();
          if (leftOscillator) leftOscillator.stop();
        } catch (e) {
          console.error("Error stopping binaural beats:", e);
        }
        if (binauralContext) {
          binauralContext.close();
        }
        binauralContext = null;
        rightOscillator = null;
        leftOscillator = null;
      }

      /* Audio Processing: Download /audio.mp3, append 10 seconds of silence,
         convert to a WAV blob & use its URL as the audio element source. */
      function loadAndProcessAudio() {
        fetch("/audio.mp3")
          .then((response) => response.arrayBuffer())
          .then((arrayBuffer) => {
            const tempAudioCtx =
              new (window.AudioContext || window.webkitAudioContext)();
            return tempAudioCtx.decodeAudioData(arrayBuffer).then((origBuffer) => {
              // Append 10 seconds of silence
              const extraSeconds = 10;
              const sampleRate = origBuffer.sampleRate;
              const extraLength = extraSeconds * sampleRate;
              const numChannels = origBuffer.numberOfChannels;
              const newLength = origBuffer.length + extraLength;
              const newBuffer = tempAudioCtx.createBuffer(
                numChannels,
                newLength,
                sampleRate
              );
              for (let channel = 0; channel < numChannels; channel++) {
                const origData = origBuffer.getChannelData(channel);
                const newData = newBuffer.getChannelData(channel);
                newData.set(origData); // Copy existing data; the rest remains 0 (silence)
              }
              // Convert AudioBuffer into WAV ArrayBuffer
              const wavArrayBuffer = audioBufferToWav(newBuffer);
              const blob = new Blob([new DataView(wavArrayBuffer)], {
                type: "audio/wav"
              });
              const blobUrl = URL.createObjectURL(blob);
              // Set the blob URL as the source for the main audio element.
              const audioEl = document.getElementById("mainAudio");
              audioEl.src = blobUrl;
              audioEl.load();
            });
          })
          .catch((error) => {
            console.error("Error processing audio:", error);
          });
      }

      /* Convert an AudioBuffer to a WAV file.
         Adapted from public domain implementations. */
      function audioBufferToWav(buffer, opt) {
        opt = opt || {};
        var numChannels = buffer.numberOfChannels;
        var sampleRate = buffer.sampleRate;
        var format = opt.float32 ? 3 : 1;
        var bitDepth = format === 3 ? 32 : 16;

        var result;
        if (numChannels === 2) {
          result = interleave(
            buffer.getChannelData(0),
            buffer.getChannelData(1)
          );
        } else {
          result = buffer.getChannelData(0);
        }
        return encodeWAV(result, numChannels, sampleRate, bitDepth);
      }

      function interleave(inputL, inputR) {
        var length = inputL.length + inputR.length;
        var result = new Float32Array(length);
        var index = 0,
          inputIndex = 0;
        while (index < length) {
          result[index++] = inputL[inputIndex];
          result[index++] = inputR[inputIndex];
          inputIndex++;
        }
        return result;
      }

      function encodeWAV(samples, numChannels, sampleRate, bitDepth) {
        var bytesPerSample = bitDepth / 8;
        var blockAlign = numChannels * bytesPerSample;
        var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
        var view = new DataView(buffer);

        /* RIFF identifier */
        writeString(view, 0, "RIFF");
        /* file length */
        view.setUint32(4, 36 + samples.length * bytesPerSample, true);
        /* RIFF type */
        writeString(view, 8, "WAVE");
        /* format chunk identifier */
        writeString(view, 12, "fmt ");
        /* format chunk length */
        view.setUint32(16, 16, true);
        /* sample format (1 = PCM) */
        view.setUint16(20, 1, true);
        /* channel count */
        view.setUint16(22, numChannels, true);
        /* sample rate */
        view.setUint32(24, sampleRate, true);
        /* byte rate (sample rate * block align) */
        view.setUint32(28, sampleRate * blockAlign, true);
        /* block align */
        view.setUint16(32, blockAlign, true);
        /* bits per sample */
        view.setUint16(34, bitDepth, true);
        /* data chunk identifier */
        writeString(view, 36, "data");
        /* data chunk length */
        view.setUint32(40, samples.length * bytesPerSample, true);

        if (bitDepth === 16) {
          floatTo16BitPCM(view, 44, samples);
        } else {
          writeFloat32(view, 44, samples);
        }
        return buffer;
      }

      function writeFloat32(output, offset, input) {
        for (var i = 0; i < input.length; i++, offset += 4) {
          output.setFloat32(offset, input[i], true);
        }
      }

      function floatTo16BitPCM(output, offset, input) {
        for (var i = 0; i < input.length; i++, offset += 2) {
          var s = Math.max(-1, Math.min(1, input[i]));
          output.setInt16(
            offset,
            s < 0 ? s * 0x8000 : s * 0x7fff,
            true
          );
        }
      }

      function writeString(view, offset, string) {
        for (var i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      /* Event Listeners & UI Setup */
      document.addEventListener("DOMContentLoaded", function () {
        const audioEl = document.getElementById("mainAudio");
        const playPauseBtn = document.getElementById("playPauseButton");
        const backBtn = document.getElementById("backButton");
        const forwardBtn = document.getElementById("forwardButton");
        const scrubber = document.getElementById("scrubber");
        const currentTimeEl = document.getElementById("currentTime");
        const totalTimeEl = document.getElementById("totalTime");

        /* Play/Pause Toggle */
        playPauseBtn.addEventListener("click", function () {
          if (audioEl.paused) {
            audioEl.play();
          } else {
            audioEl.pause();
          }
        });
        audioEl.addEventListener("play", function () {
          playPauseBtn.textContent = "Pause";
          startBinauralBeats();
        });
        audioEl.addEventListener("pause", function () {
          playPauseBtn.textContent = "Play";
          stopBinauralBeats();
        });

        /* Jump Back/Forward by 10 seconds */
        backBtn.addEventListener("click", function () {
          audioEl.currentTime = Math.max(0, audioEl.currentTime - 10);
        });
        forwardBtn.addEventListener("click", function () {
          audioEl.currentTime = Math.min(
            audioEl.duration || 0,
            audioEl.currentTime + 10
          );
        });

        /* Update Time Display & Scrubber */
        audioEl.addEventListener("timeupdate", function () {
          currentTimeEl.textContent = formatTime(audioEl.currentTime);
          if (audioEl.duration) {
            totalTimeEl.textContent = formatTime(audioEl.duration);
            scrubber.value =
              (audioEl.currentTime / audioEl.duration) * 100;
          }
        });
        audioEl.addEventListener("loadedmetadata", function () {
          if (audioEl.duration) {
            totalTimeEl.textContent = formatTime(audioEl.duration);
          }
        });

        /* Allow Seeking via the Scrubber */
        scrubber.addEventListener("input", function () {
          if (audioEl.duration) {
            audioEl.currentTime = (scrubber.value / 100) * audioEl.duration;
          }
        });

        /* Begin the audio loading & processing */
        loadAndProcessAudio();
      });
    </script>
  </body>
</html>
